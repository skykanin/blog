#+title: Notation As A Tool Of Thought
#+date: 2023-03-26T19:29:00+02:00
#+draft: true
#+tags[]: array BQN functional iversonian

Last year while doing [[https://adventofcode.com/][advent of code]] I came across the [[https://en.wikipedia.org/wiki/APL_(programming_language)][APL]] programming language. I had always been interested in exploring array programming, but the highly imperative nature of tools like [[https://numpy.org/][NumPy]], [[https://www.r-project.org/][R]], [[https://julialang.org/][Julia]] and [[https://www.mathworks.com/products/matlab.html][Matlab]] turned me off. Luckily APL has the best of both worlds as a functional array programming language with first class support for multi-dimensional arrays. More recently I've been playing around with [[https://mlochbaum.github.io/BQN/][BQN]], a modern variant of APL, which is what I'll be exploring today.

* History

In 1957 [[https://en.wikipedia.org/wiki/Kenneth_E._Iverson][Ken Iverson]] developed a mathematical notation for manipulating arrays which became the basis of the book he later published called /A Programming Language/. The preface states its premise:

#+begin_quote
Applied mathematics is largely concerned with the design and analysis of explicit procedures for calculating the exact or approximate values of various functions. Such explicit procedures are called algorithms or programs. Because an effective notation for the description of programs exhibits considerable syntactic structure, it is called a programming language.
#+end_quote

This notation would be used inside IBM, where he worked, for short research reports on computer systems.

* Hello BQN!

As APL is quite an old idea by now the language has accrued many irregular and burdensome aspects. BQN attempts to address these issues and incorporates concepts developed over the years of APL in practice. One of the first things to notice about the syntax is that it uses unicode characters for primitives.

#+BEGIN_SRC bqn
⊑¨ "Big"‿"Questions"‿"Notation"
"BQN"
#+END_SRC

Expressions in BQN consists of subjects, functions and modifiers. Functions can be applied to subjects or grouped into trains, while modifiers can be applied to subjects or functions. The most important kinds of application are:

| example | left | main  | right | output   | name       |
|---------+------+-------+-------+----------+------------|
| =↕ 10=  | =w?= | =F=   | =x=   | Subject  | Function   |
| =+ ⋈ -= | =F?= | =G=   | =H=   | Function | Train      |
| =x´=    | =F=  | =_m=  |       | Function | 1-Modifier |
| =2⊸⌊=   | =F=  | =_c_= | =G=   | Function | 2-Modifier |

In the table, =?= marks an optional left argument. If there isn't a value in that position, the main function will be called with only one argument.

All primitive functions in BQN have two forms. Depending on how many arguments are applied they behave differently. When one argument is applied it's known as /monadic/ and when two arguments are applied; /dyadic/.

#+BEGIN_SRC bqn
× 4
1

2 × 4
8
#+END_SRC

In its monadic form =×= is **signum**, when applied dyadically its multiplication.

#+BEGIN_SRC bqn
⌽ 1‿2‿3‿4‿5
⟨ 5 4 3 2 1 ⟩

2 ⌽ 1‿2‿3‿4‿5
⟨ 3 4 5 1 2 ⟩
#+END_SRC

In its monadic form =⌽= is **reverse**, when applied dyadically its **rotate**. Lists in BQN can either be written using the =⟨⟩= syntax with comma separated values or using the stranding =‿= notation =1‿2‿3=.

One might think with all these prefix and infix functions parsing the fixity becomes difficult, but luckily there is only /one/ rule you need to remember. All function application is right associative, regardless of the function.

#+BEGIN_SRC bqn
10 ÷ (2 + 3) # is the same as
10 ÷ 2 + 3   # which reduces to
2
#+END_SRC

BQN also has 1-/2-modifiers. Which modify the behaviour of the arguments that are passed to them.

#+BEGIN_SRC bqn
+´ ⟨ 1, 2, 3, 4, 5 ⟩ # fold aka. reduce
15

+` ⟨ 1, 1, 1, 1, 1 ⟩ # scan
⟨ 1 2 3 4 5 ⟩

×∘⊑ 7‿2‿3 # function composition
1

#+END_SRC

Modifiers are easily recognisable. All 1-Modifiers are superscript, while all 2-Modifiers contain an unbroken circle. All modifiers are left associative.

BQN also supports blocks otherwise known as anonymous functions or lambdas where =𝕩= denotes the left argument and =𝕨= denotes the right. One can also assign variables using the =←= arrow.

#+BEGIN_SRC bqn
Evens ← { (¬ 2 | 𝕩) / 𝕩 } # even elements

Evens ⟨ 1, 2, 3, 4 ⟩
⟨ 2 4 ⟩

Windows ← { 𝕨 ↕ 1 + ↕ 𝕩 } # 𝕨 element windows in 1-indexed range 𝕩

2 Windows 3
┌─
╵ 1 2
  2 3
      ┘
#+END_SRC
